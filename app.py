import os
import sys
import argparse
import numpy as np
from PIL import Image
import signal
import time
signal.signal(signal.SIGINT, signal.SIG_DFL)

import OpenGL.GL as gl
from glfwBackend import glfwApp
import imgui
from imgui.integrations.glfw import GlfwRenderer

# Local imports
from fieldAnimation import FieldAnimation


CHOICES = "epole spiral wind diverging test".split()

#------------------------------------------------------------------------------
def test():
    """ 
    http://reference.wolfram.com/language/ref/StreamPlot.html
    """
    
    n = 64
    Y, X = np.mgrid[-3:3:64j, -3:3:64j]
    #U = X.copy()
    #U.flat[:] = 0.0
    #V = Y.copy()
    #V.flat[:] = -5.0
    
    # OK
    #U = Y.copy()
    #V = -X+Y*(1-X**2-2*Y**2)
    
    ## OK
    #U = Y.copy()
    #V = -Y + X - X**3
    
    #OK
    #U = 2 *X +Y-X*(X**2+Y**2)
    #V = -Y - Y *(X**2+Y**2)
    
    # OK
    #U = X**2
    #V = -Y

    # OK
    #U = 2 * (Y-X) + X * (1-X**2)
    #V = -2 * (Y-X) + Y * (1-Y**2)
    
    # OK
    U = Y.copy()
    V = X-X**3
    
    #import pylab
    #pylab.streamplot(X, Y, U, V, density=2.0)
    #pylab.show()
    return np.flipud(np.dstack((U, -V)))

def diverging_ok():
    """ Diverging field """
    n = 64
    x = np.linspace(-2, 2, n)
    y = np.linspace(-2, 2, n)
    X, Y = np.meshgrid(x, y)
    T = np.arctan2(Y - n / 2., X - n/2.)
    R = 10 + np.sqrt((Y - n / 2.0) ** 2 + (X - n / 2.0) ** 2)
    U, V = X, -Y
    #U, V = R * np.cos(T), R * np.sin(T)
    
    #import pylab
    #pylab.streamplot(X, Y, V, U, color='cornflowerblue')
    #pylab.show()
    
    return np.dstack((U, V))
    #return np.dstack((V, U))

def simple2():
    """ Diverging field """
    n = 64
    x = np.linspace(-2, 2, n)
    y = np.linspace(-2, 2, n)
    X, Y = np.meshgrid(x, y)
    T = np.arctan2(Y - n / 2., X - n/2.)
    R = 10 + np.sqrt((Y - n / 2.0) ** 2 + (X - n / 2.0) ** 2)
    U, V = X, -Y
    #U, V = R * np.cos(T), R * np.sin(T)
    return np.dstack((U, V))
    #return np.dstack((V, U))


def diverging():
    """ Diverging field """
    Y, X = np.mgrid[-2:2:64j, -2:2:64j]
    U = -1 - X**2 + Y
    V = 1 + X - Y**2
    #import pylab
    #pylab.streamplot(X,Y,U, V)
    #pylab.streamplot(X,Y, U, np.flipud(V))
    #pylab.streamplot(X,Y,V, U)
    #pylab.streamplot(X,Y,U, np.flipud(V))
    #pylab.streamplot(X,Y,U, np.flipud(V))
    #pylab.show()
    #raise SystemExit
    #field = np.hypot(
    return np.flipud(np.dstack((U, -V)))


#------------------------------------------------------------------------------
def E(q, r0, x, y):
    """ Return the electric field vector E=(Ex, Ey) due to charge q at r0.
    """
    den = np.hypot(x - r0[0], y - r0[1]) ** 1.5
    return q * (x - r0[0]) / den, q * (y - r0[1]) / den

#------------------------------------------------------------------------------
#def E(q, r0, x, y):
    #""" Return the electric field vector E=(Ex, Ey) due to charge q at r0.
    #"""
    #return x + y, y - x

#------------------------------------------------------------------------------
def Spiral(q, r0, x, y, origin=(0.8, - 0.8), clockwise=False):
    """ Return a spiral field vector with origin at `origin`
    """
    x, y = x - origin[0], y - origin[1]
    if clockwise:
        return x - y, x + y
    else:
        return y - x, -x - y

##------------------------------------------------------------------------------
def createField(m=64, n=64, eq=E, charges=1):
    """ Return n x m x 2 2D array with Electric field values
        generated by a (2 * charges) electric charges configuration
        Electric field follows equation eq.
    """
    x = np.linspace(-2, 2, n)
    y = np.linspace(-2, 2, m)
    X, Y = np.meshgrid(x, y)
#def createField(m=16, n=16, eq=E, charges=1):
    #""" Return n x m x 2 2D array with Electric field values
        #generated by a (2 * charges) electric charges configuration
        #Electric field follows equation eq.
    #"""
    #x = np.linspace(-20, 20, n)
    #y = np.linspace(-20, 20, m)
    #X, Y = np.meshgrid(x, y)

    # Create a multipole with nq charges of alternating sign, equally spaced
    # on the unit circle.
    nq = 2 ** int(charges)
    charges = []
    for i in range(nq):
        q = i % 2 * 2 - 1
        charges.append((q,
                (np.cos(2 * np.pi * i / nq), np.sin(2 * np.pi * i / nq))))

    Ex, Ey = np.zeros((m, n)), np.zeros((m, n))
    for charge in charges:
        ex, ey = eq(*charge, x=X, y=Y)
        Ex += ex
        Ey += ey
    return np.flipud(np.dstack((Ex, -Ey)))

#------------------------------------------------------------------------------
def userInterface(renderer, graphicItem):
    """ Control graphicItem parameters interactively
    """
    if not renderer:
        return

    renderer.process_inputs()
    imgui.new_frame()
    imgui.begin('Controls', closable=True,
            flags=imgui.WINDOW_ALWAYS_AUTO_RESIZE)

    # Speed Rate
    changed, speed = imgui.slider_float('Speed',
        graphicItem.speedFactor, 0, 10.0)
    if changed:
        graphicItem.speedFactor = speed

    # Drop Rate
    changed, dropRate = imgui.slider_float('Drop rate',
        graphicItem.dropRate, 0, 0.1)
    if changed:
        graphicItem.dropRate = dropRate

    # Drop Rate Bump
    changed, dropRateBump = imgui.slider_float('Drop rate bump',
        graphicItem.dropRateBump, 0, 0.1)
    if changed:
        graphicItem.dropRateBump = dropRateBump

    # Field Scaling
    changed, fieldScaling = imgui.slider_float('Field Scaling',
        graphicItem.fieldScaling, 0, 0.01, '%.4f')
    if changed:
        graphicItem.fieldScaling = fieldScaling

    # Unbknown const
    changed, opacity = imgui.slider_float('Opacity',
        graphicItem.fadeOpacity, 0.900, 0.999, '%.4f')
    if changed:
        graphicItem.fadeOpacity = opacity

    # Palette
    changed, color = imgui.color_edit3('Color', *graphicItem.color)
    if changed:
        graphicItem.color = color
    imgui.same_line()
    changed, palette = imgui.checkbox("Palette", graphicItem.palette)
    if changed:
        graphicItem.palette = palette

    # Point size
    changed, pointSize = imgui.input_int("Point size",
        graphicItem.pointSize, 1, 1, 1)
    if changed:
        if pointSize > 5:
            pointSize = 5
        elif pointSize < 1:
            pointSize = 1
        graphicItem.pointSize = pointSize

    # Number of Points
    changed, tracersCount = imgui.drag_int("Number of "
        "Tracers", graphicItem.tracersCount, 4096.0, 64, 1000000)
    if changed:
        graphicItem.tracersCount = tracersCount

    # Periodic border
    changed, periodic = imgui.checkbox("Periodic", graphicItem.periodic)
    if changed:
        graphicItem.periodic = periodic

    # Draw field
    changed, drawfield = imgui.checkbox("Draw Field", graphicItem.drawField)
    if changed:
        graphicItem.drawField = drawfield

    imgui.end()
    imgui.render()

#==============================================================================
class GLApp(glfwApp):
    def __init__(self, title, width, height, fields, options):
        super(GLApp, self).__init__(title, width, height)
        self._fields = fields

        if options.gui:
            self._renderer = GlfwRenderer(self.window(), False)
        else:
            self._renderer = None

        self._ifield = CHOICES.index(options.choose)

        # Add Field Animation overlay
        self._fa = FieldAnimation(width, height,
                self._fields[self._ifield], options=options)
        if options.draw_field:
            self._fa.drawField = True
        self._t0 = time.time()
        self._fps = 0
        self.options = options

    def renderScene(self):
        super(GLApp, self).renderScene()
        self._fa.draw()
        self._fps += 1
        userInterface(self._renderer, self._fa)
        now = time.time()
        if now - self._t0 >= 1:
            if self.options.fps:
                self.setTitle("%s - %s FPS" % (self.title(), self._fps))
            self._fps = 0
            self._t0 = time.time()


    def onKeyboard(self, window, key, scancode, action, mode):
        if key == GLApp.KEY_G and action == GLApp.PRESS:
            # Draw the GUI
            if self._renderer is None:
                self._renderer = GlfwRenderer(self.window(), False)
                self._renderer.process_inputs()
            else:
                self._renderer.shutdown()
                self._renderer = None
        elif key == GLApp.KEY_N and action == GLApp.PRESS:
            # Set next field
            self._ifield = (self._ifield + 1) % len(self._fields)
            self._fa.setField(self._fields[self._ifield])
        elif key == GLApp.KEY_F and action == GLApp.PRESS:
            # Draw the field
            self._fa.drawField = not self._fa.drawField

        super(GLApp, self).onKeyboard(window, key, scancode, action, mode)

    def onResize(self, window, width, height):
        gl.glViewport(0, 0, width, height)
        self._fa.setSize(width, height)


#------------------------------------------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
            description="\nField Animation example",
            add_help=True,
            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
            prog=os.path.basename(sys.argv[0]))

    parser.add_argument('-f', '--draw_field', action='store_true',
            default=False,
            help=("Draw vector field as background image ")
            )
    parser.add_argument('-c', '--choose',
            choices=CHOICES,
            default="wind",
            help=("Choose field to animate ")
            )
    parser.add_argument('-p', '--fps', action='store_true', default=False,
            help=("Count Frames Per Second ")
            )
    parser.add_argument('-k', '--cs', action='store_true', default=False,
            help=("Use compute shader ")
            )
    parser.add_argument('-g', '--gui', action='store_true', default=False,
            help=("Add gui control window ")
            )
    options = parser.parse_args(sys.argv[1:])

    fields = [
            createField(eq=E),
            createField(eq=Spiral),
            np.load("wind_2016-11-20T00-00Z.npy"),
            diverging(),
            test()
            ]

    app = GLApp('Field Animation', 600, 600, fields, options)
    app.run()
