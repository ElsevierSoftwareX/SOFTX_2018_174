import glfw
import OpenGL.GL as gl
import sys
import numpy as np
import ctypes
from shader import Shader
import math
#import gl
#import OpenGL.GL as gll
from PIL import Image

vs = """
#version 330

layout (location = 0) in vec2 Position;
layout (location = 1) in vec2 texCoords;

out vec2 texCoords0;

void main()
{
    texCoords0 = texCoords;
    gl_Position = vec4(Position, 0.0, 1.0);
}

"""

fs = """
#version 330

const float pi = 3.141592653589793238462643383279;

uniform sampler2D gMap;

// CubeHelix parameters
// START colour (1=red, 2=green, 3=blue; e.g. 0.5=purple);
uniform float start;
// ROTS  rotations in colour (typically -1.5 to 1.5, e.g. -1.0
//       is one blue->green->red cycle);
uniform float rot;
// Hue (colour saturation) 0 = greyscale.
uniform float gamma;
uniform bool reverse;
uniform bool useHue;
uniform float minSat;
uniform float maxSat;
uniform float minLight;
uniform float maxLight;
uniform float startHue;
uniform float endHue;

out vec4 fragColor;
in vec2 texCoords0;

vec3 cubeHelix(float x)
{
   // Implement D.A. Green's cubehelix colour scheme
   // Input x ranges from 0 to 1.
   float red, green, blue, frc, satar, amp, angle, newstart, newrot;

   if (useHue)
   {
        newstart = (startHue / 360. - 1) * 3.;
        newrot = endHue / 360. - newstart / 3. - 1.;
   }
   else{
       newstart = start;
       newrot = rot;
   }

   frc = int(x*255.)*(maxLight-minLight)/255.+minLight;
   angle = 2.0 * pi * (newstart / 3.0 + newrot * frc + 1.);
   frc = pow(frc, gamma);

   satar = int(x*255.)*(maxSat-minSat)/255.+minSat;
   amp = satar * frc * (1. - frc) / 2.;

   red   = frc + amp * (-0.14861 * cos(angle) + 1.78277 * sin(angle));
   green = frc + amp * (-0.29227 * cos(angle) - 0.90649 * sin(angle));
   blue  = frc + amp * (1.97294 * cos(angle));

   if (red > 1.)
       red = 1.;
   else if (red < 0.)
       red = 0.;
   if (green > 1.)
       green = 1.;
   else if (green < 0.)
       green = 0.;
   if (blue > 1.)
       blue = 1.;
   else if (blue < 0.)
       blue = 0.;


    if (reverse){
        red = 1.0-red;
        green = 1.0-green;
        blue = 1.0-blue;
    }

    return vec3(red, green, blue);

}


float jet_red(float x) {
    if (x < 0.7) {
        return 4.0 * x - 1.5;
    } else {
        return -4.0 * x + 4.5;
    }
}

float jet_green(float x) {
    if (x < 0.5) {
        return 4.0 * x - 0.5;
    } else {
        return -4.0 * x + 3.5;
    }
}

float jet_blue(float x) {
    if (x < 0.3) {
       return 4.0 * x + 0.5;
    } else {
       return -4.0 * x + 2.5;
    }
}

vec3 jet(float x) {
    float r = clamp(jet_red(x), 0.0, 1.0);
    float g = clamp(jet_green(x), 0.0, 1.0);
    float b = clamp(jet_blue(x), 0.0, 1.0);

    return vec3(r, g, b);
}


void main()
{   float value = texture(gMap, texCoords0).r;
    //fragColor = vec4(jet(value), 1.0);
    fragColor = vec4(cubeHelix(value), 1.0);
    //fragColor = vec4(texture(gMap, texCoords0).xyz, 1.0);
}

"""
def E(q, r0, x, y):
    """ Return the electric field vector E=(Ex, Ey) due to charge q at r0.
    """
    den = np.hypot(x - r0[0], y - r0[1]) ** 1.5
    return q * (x - r0[0]) / den, q * (y - r0[1]) / den

#------------------------------------------------------------------------------
def createField(m=64, n=64, eq=E, charges=1):
    """ Return n x m x 2 2D array with Electric field values
        generated by a (2 * charges) electric charges configuration
        Electric field follows equation eq.
    """
    x = np.linspace(-2, 2, n)
    y = np.linspace(-2, 2, m)
    X, Y = np.meshgrid(x, y)

    # Create a multipole with nq charges of alternating sign, equally spaced
    # on the unit circle.
    nq = 2 ** int(charges)
    charges = []
    for i in range(nq):
        q = i % 2 * 2 - 1
        charges.append((q,
                (np.cos(2 * np.pi * i / nq), np.sin(2 * np.pi * i / nq))))

    Ex, Ey = np.zeros((m, n)), np.zeros((m, n))
    for charge in charges:
        ex, ey = eq(*charge, x=X, y=Y)
        Ex += ex
        Ey += ey
    return np.dstack((Ex, Ey))

def main():
    glfw.init()
    glfw.window_hint(glfw.CONTEXT_VERSION_MAJOR, 3)
    glfw.window_hint(glfw.CONTEXT_VERSION_MINOR, 3)
    glfw.window_hint(glfw.OPENGL_PROFILE, glfw.OPENGL_CORE_PROFILE)
    glfw.window_hint(glfw.RESIZABLE, gl.GL_FALSE)

    window = glfw.create_window(1024, 768, "Texture Test", None, None)

    if not window:
        glfw.terminate()
        sys.exit()

    glfw.make_context_current(window)
    gl.glClearColor(1.0, 1.0,1.0, 1.0)
    if False:
        field = createField()
    else:
        field = np.load("wind_2016-11-20T00-00Z.npy")
    data = np.flipud(np.hypot(field[:,:,0], field[:,:,1]))
        
    shader = Shader(vs, fs)
    shader.addUniform('gMap')
    # CubeHelix
    shader.addUniform('start')
    shader.addUniform('gamma')
    shader.addUniform('rot')
    shader.addUniform('reverse')
    shader.addUniform('minSat')
    shader.addUniform('maxSat')
    shader.addUniform('minLight')
    shader.addUniform('maxLight')
    shader.addUniform('startHue')
    shader.addUniform('endHue')
    shader.addUniform('useHue')
    
    quad = np.zeros(4, dtype=[('vert', 'f4', 2),('tex', 'f4', 2)])

    quad['vert'] = np.array([[-1, 1],
                                [1, 1],
                                [1, -1],
                                [-1, -1]], np.float32)

    quad['tex'] = np.array([[0, 1],
                        [1, 1],
                        [1, 0],
                        [0, 0]], np.float32)

    indices = np.array([0, 1, 2, 2, 3, 0], np.int32)

    vaoQuad = gl.glGenVertexArrays(1)
    gl.glBindVertexArray(vaoQuad)
    quadVBO = gl.glGenBuffers(1)
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, quadVBO)
    gl.glBufferData(gl.GL_ARRAY_BUFFER, quad, gl.GL_STATIC_DRAW)

    IBO = gl.glGenBuffers(1)
    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, IBO)
    gl.glBufferData(gl.GL_ELEMENT_ARRAY_BUFFER, indices, gl.GL_STATIC_DRAW)

    gl.glEnableVertexAttribArray(0)
    gl.glVertexAttribPointer(0, 2,   gl.GL_FLOAT, gl.GL_FALSE, 4*4,
                                ctypes.c_void_p(0))
    gl.glEnableVertexAttribArray(1)
    gl.glVertexAttribPointer(1, 2,   gl.GL_FLOAT, gl.GL_FALSE, 4*4,
                                ctypes.c_void_p(8))
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, 0)
    gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, 0)
    gl.glBindVertexArray(0)

    # create texture
    if False:
        img = Image.open('marble.jpg')
        img = img.convert('RGBA')
        data = np.asarray(img, dtype=np.uint8)    
        tex = gl.glGenTextures(1)
        gl.glBindTexture(gl.GL_TEXTURE_2D, tex)
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR);
        gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_RGBA, data.shape[1], data.shape[0], 0, gl.GL_RGBA, gl.GL_UNSIGNED_BYTE, data)
        gl.glBindTexture(gl.GL_TEXTURE_2D, 0);    
    else:
        #data = (255.*data/data.max()).astype(np.uint8)
        data = data/data.max()
        #print(data.min(), data.max())
        data = np.asarray(data, np.float32)
        tex = gl.glGenTextures(1)
        gl.glBindTexture(gl.GL_TEXTURE_2D, tex)
        #gl.glPixelStorei(gl.GL_UNPACK_ALIGNMENT, 4)
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR);
        gl.glTexImage2D(gl.GL_TEXTURE_2D, 0, gl.GL_R32F, data.shape[1], data.shape[0], 0, gl.GL_RED, gl.GL_FLOAT, data)
        gl.glBindTexture(gl.GL_TEXTURE_2D, 0);   

    while not glfw.window_should_close(window):
        gl.glActiveTexture(gl.GL_TEXTURE0)
        gl.glBindTexture(gl.GL_TEXTURE_2D, tex)

        shader.bind()
        gl.glBindVertexArray(vaoQuad)
        gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, IBO)
        shader.setUniform('gMap', 0)
        shader.setUniformf('start', 1.0)
        shader.setUniformf('gamma', 0.9)
        shader.setUniformf('rot', -5.3)
        shader.setUniformi('reverse', False)
        shader.setUniformf('minSat', 0.2)
        shader.setUniformf('maxSat', 5.0)
        shader.setUniformf('minLight', 0.5)
        shader.setUniformf('maxLight', 0.9)
        shader.setUniformf('startHue', 240.0)
        shader.setUniformf('endHue', -300.0)
        shader.setUniformi('useHue', True)        
        
        gl.glDrawElements(gl.GL_TRIANGLES, indices.size, gl.GL_UNSIGNED_INT, ctypes.c_void_p(0))
        
        shader.unbind()
        gl.glBindBuffer(gl.GL_ELEMENT_ARRAY_BUFFER, 0)
        gl.glBindVertexArray(0)
        
        glfw.swap_buffers(window)
        glfw.poll_events()

    glfw.terminate()


if __name__ == "__main__":
    main()

